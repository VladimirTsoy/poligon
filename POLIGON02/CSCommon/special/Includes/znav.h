/*!*****************************************************************\
* \file    ZNAV.h
* \brief   Файл с описание структуры навигационных данных и функций 
*          пересчета координатной информации из одной системы 
*          координат в другую
********************************************************************
* \author  (c) ОАО "Концерн "Вега", 2014  
* \author  Alexander V. Metelkin 
* \date    14.03.2014 создан
* \date    27.07.2015 последнее изменение (v1.3)
\*******************************************************************/
#ifndef __ZNAV_H
  #define __ZNAV_H

#include <cmath>
#include <cstring>

// Builder хочет именно стд-шные функции
#ifdef __BORLANDC__
	using namespace std;
#endif

//////////////////////////
#pragma pack (push, 4)
//////////////////////////

static const double GEO_PI   = 3.14159265358979323846;
static const double GEO_PI2  = 6.28318530717958647692;  // PI * 2 = 360
static const double GEO_PI12 = 1.57079632679489661923;  // PI / 2 = 90 град

static const double GEO_RZ   = 6378245.0;        // длина большой полуоси эллипсоида Красовского
static const double GEO_E2   = 0.006693421623;   // = e*e
static const double GEO_E1   = 0.993306578377;   // = 1 - e*e

#define GEO_HTOZ       0x00000010ul // восстанавливается координата Z по H
// режимы пересчета x,y,v -> x,y,v функции xyv2xyv(...)
#define GEO_XYVTOPAD   0x00000100ul // пересчитать значения  x y h v из СК РМ в СК ПАД
#define GEO_XYVTOPM    0x00000200ul // пересчитать значения  x y h v из СК А100/СК ПАД в СК УТ РМ
#define GEO_XYVTOUT    GEO_XYVTOPM  // пересчитать значения  x y h v из СК А100/СК ПАД в СК УТ РМ
#define GEO_XYVTOA100  0x00000400ul // пересчитать значения  x y h v из СК РМ в А100
//--------------------------------------------------------------------
// Вычисление радиуса кривизны первого вертикала эллипсоида Красовского
double vertical(const double &sf);
//--------------------------------------------------------------------
// Восстановление координаты Z по по плоскостным координатам X,Y и высоте h,
// заданными в СК с началом координат в точке (F,L,H) где:
// fk - широта УТ; hk - высота УТ;
double htoz(struct TUxyh* const pXYH,const double &fk,const double &hk);

//-------------------------
// точка double f-l-h
//-------------------------
struct TUflh
{
  double f;  // широта
  double l;  // долгота
  double h;  // высота (над эллипсоидом или барометрическая)
  //
  TUflh() { f=0.; l=0.; h=0.; }
  TUflh(const double &ff, const double &ll, const double &hh) { f = ff; l = ll; h = hh; }
  TUflh(const TUflh& flh) { f = flh.f; l = flh.l; h = flh.h; }

  TUflh& operator=(const TUflh& flh)
  {
    f = flh.f;
    l = flh.l;
    h = flh.h;
    return *this;
  }
  bool operator ==(const TUflh& pt) const { return (f == pt.f) && (l == pt.l) && (h == pt.h); }
  bool operator !=(const TUflh& pt) const { return !(pt == *this); }
};

//-------------------------
// точка double x-y-h
//-------------------------
struct TUxyh
{
  double x;
  double y;
  double h;
  //
  TUxyh() { x=0.; y=0.; h=0.; }
  TUxyh(const double &xx, const double &yy, const double &hh) { x = xx; y = yy; h = hh; }
  //
  void operator *=(const double &k) { x*=k; y*=k; h*=k; }
  void operator /=(const double &k) { x/=k; y/=k; h/=k; }
  bool operator ==(const TUxyh& pt) const { return (x == pt.x) && (y == pt.y) && (h == pt.h); }
  bool operator !=(const TUxyh& pt) const { return !(pt == *this); }
};

//-------------------------
// 3-мерная точка
//-------------------------
struct TU3d
{
  double x;
  double y;
  double z;
  //
  TU3d() { x=0.; y=0.; z=0.; }
  TU3d(const double &xx, const double &yy, const double &zz) { x = xx; y = yy; z = zz; }
  friend double operator -(const TU3d &p1, const TU3d &p2)
  {
    return sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y) + (p1.z-p2.z)*(p1.z-p2.z));
  }
  //
  void operator *=(const double &k) { x*=k; y*=k; z*=k; }
  void operator /=(const double &k) { x/=k; y/=k; z/=k; }
  bool operator ==(const TU3d& pt) const { return (x == pt.x) && (y == pt.y) && (z == pt.z); }
  bool operator !=(const TU3d& pt) const { return !(pt == *this); }
};

//-------------------------
// 3-мерная точка с компонентами скорости
//-------------------------
struct TU3dv : public TU3d
{
  double vx; // составляющая скорости на север
  double vy; // составляющая скорости на восток
  double vz; // вертикальная составляющая скорости
  //
  TU3dv(): TU3d() { vx=0.; vy=0.; vz=0.; }
  TU3dv(const double &xx, const double &yy, const double &zz, const double &vxx=0., const double &vyy=0., const double &vzz=0.): TU3d(xx, yy, zz)
       { vx=vxx; vy=vyy; vz=vzz; }
  TU3dv(const TU3dv& pt3dv): TU3d(pt3dv.x, pt3dv.y, pt3dv.z) { vx=pt3dv.vx; vy=pt3dv.vy; vz=pt3dv.vz; }
};

/******************************************************************\
 зона навигациионных и азимутальных параметров ()
\******************************************************************/
struct TZNav 
{
  TUflh  FLHn,    // геод. широта(рад), долгота(рад) и высота носителя [м]
         FLHk,    // геод. широта(рад), долгота(рад) и высота условной точки [м]
         FLPAD;   // геод. широта, долгота опорной УТ ПАД
  double sfk,     //            sin fk (условной точки)
         cfk,     //            cos fk
         slk,     //            sin lk
         clk;     //            cos ik
  TU3d	 GeoUT;   // геоцентрические координаты условной точки (xok,zok,yok) [м]
  double vertk;   // радиуса кривизны первого вертикала эллипсоида Красовского в УТ
  double t;       // время формирования сообщения UTC
                  // Составляющие скорости носителя относительно местного меридиана:
  float  wn,      //   скорость носителя Север-Юг           [м/сек]
         we,      //   скорость носителя Восток-Запад       [м/сек]
         vh;      //   вертикальная составляющая скорости
  float  wnut,    // Составляющие вектора скорости носителя [м/сек]     
         weut,    //             в осях СК УТ 
         whut;    //   (относительно меридиана рабочей УТ)
  float  ax,      // линейное ускорение носителя по линии пути
         ay,      // линейное ускорение носителя перпендикулярно линии пути
         az;      // линейное ускорение носителя по вертикали
  float  psin,    // истинный курс носителя (в местной системе координат)[рад]
         v,       // путевая скорость                       [м/сек]
		 wayAngle;// путевой угол                           [рад]
  float  gam,     // крен носителя (правый - положительный) [рад]
         tet,     // тангаж носителя (выше горизонта - положительный) [рад]
         omPsi,   // угловая скорость изменения курса
         omGam,   // угловая скорость изменения крена
         omTet;   // угловая скорость изменения тангажа
		          // --- Азимуты относительно местного меридиана (севера) ---
  float  betS,    // азимут нормали антенны S-диапазона (азимутальный угол диаграммы направленности антенны)
         betP,    // азимут нормали антенн Р-диапазона и САЗО-ГО (азимутальный угол д.н. антенны САЗО)
         betR,    // азимут нормали антенн САЗО-СГО изделия Б5
                  // --- Азимуты нормали антенны относительно оси самолета ---
		 betSA,   // азимут нормали антенны S-диапазона 
		 betPA,   // азимут нормали антенны Р-диапазона и САЗО-ГО (азимутальный угол д.н. антенны САЗО)
		 betRA;   // азимут нормали антенны САЗО-СГО изделия Б5
  float  omBet;   // скорость вращения обтекателя
  double m[15];   // Коэффициенты для пересчета координат        
                  //   из подвижной СК (СК А100) в СК УТ и наоборот.       
  unsigned char  ucNumUT, // Номер рабочей УТ
                 ucNavStatus,  // статус навигационной информации:
                 #define  NAV_STATUS_NO_DATA    0 // нет данных
                 #define  NAV_STATUS_INCOMPLETE 1 // неполные данные
                 #define  NAV_STATUS_OK         2 // есть данные
                 ucSatStatus,  // статус спутниковой информации:
                 #define  SAT_STATUS_NO_DATA    0 // нет данных
                 #define  SAT_STATUS_BINS       1 // данные БИНС
                 #define  SAT_STATUS_OK         2 // данные СНС
                 ucAzStatus;   // статус азимутальной информации
                 #define  AZ_STATUS_NO_DATA     0 // нет данных
                 #define  AZ_STATUS_NO_AC       1 // нет азимута от оси
                 #define  AZ_STATUS_NO_NORD     2 // нет азимута от севера
                 #define  AZ_STATUS_DATA_YES    3 // есть данные
  //
  TZNav() { memset(this, 0, sizeof(TZNav)); }
  //--------------------------------------------------------------------
  // Признак возможности работы с навигационными данными
  bool IsEnable(void) { return ((ucNumUT && ucNavStatus != NAV_STATUS_NO_DATA) ? true : false); }
  bool IsEnableNav(void) { return ((ucNumUT && ucNavStatus != NAV_STATUS_NO_DATA && ucSatStatus != SAT_STATUS_NO_DATA) ? true : false); }
  //--------------------------------------------------------------------
  // получить пpямоугольные кооpдинаты носителя (xn,yn,zn) в СК УТ [м] 
  double getXN(void) { return  m[3]; } // получить xn 
  double getYN(void) { return  m[7]; } // получить yn
  double getZN(void) { return  m[11];} // получить zn 
  //--------------------------------------------------------------------
  double getHN(void) { return  FLHn.h; } // получить высота носителя [м]
  //--------------------------------------------------------------------
  // получить пpямоугольные кооpдинаты УТ (xt,yt,zt) в подвижной СК носителя (СК А100)  
  double getXT(void) { return  m[12]; } // получить xt 
  double getYT(void) { return  m[13]; } // получить yt 
  double getZT(void) { return  m[14]; } // получить zt 
  //--------------------------------------------------------------------
  // Программа вычисления геодезических координат объекта (F,L,H) по его    
  // прямоугольным координатам (X,Y,Z), заданным в СК РМ (СК УТ) 
  // ulMode - параметр определяет необходимость восстановление координаты z по высоте h 
  void xy2fl(const unsigned long& ulMode,TU3d* const pXYZ,TUflh* const pFLH);
  //--------------------------------------------------------------------
  // Пограмма вычисления прямоугольных координат (X,Y,Z) точки в любой СК по её
  // геодезическим координатам (F,L,H)
  // flhFrom - геодезические координаты пересчитываемой точки;
  // flhTo   - геодезические координаты условной точки конечной СК;
  // XYZ     - прямоугольные координаты пересчитываемой точки       
  void fl2xy(TUflh* const pFLHFrom,TUflh* const pFLHTo,TU3d* const pXYZ);
  //--------------------------------------------------------------------
  // Пограмма вычисления прямоугольных координат (X,Y,Z) точки в СК УТ РМ
  // по её геодезическим координатам (F,L,H)
  void fl2xy(TUflh* const pFLHFrom,TU3d* const pXYZ) { fl2xy(pFLHFrom,NULL,pXYZ); }
  //--------------------------------------------------------------------
  // Программа пересчета координат из подвижной СК, связанной с
  // носителем (СК А100), в СК УТ РМ и наоборот (A100->PM/PM->A100)
  // ulMode  - параметр определяет направление пересчета и необходимость
  //           восстановление координаты z по высоте h
  void xy2xy(const unsigned long& ulMode,TU3d* const pXYFrom,TU3d* const pXYTo, const double& t);
  //--------------------------------------------------------------------
  // Программа пересчета координат и составляющих вектора скорости
  // из прямоугольной СК, связанной с носителем (СК А100), в СК УТ РМ (x,y,v <-> x,y,v) 
  // и обратно (A100->PM/PM->A100), где:
  // ulMode  - параметр определяет направление пересчета и необходимость
  //           восстановление координаты z по высоте h
  void xyv2xyv(const unsigned long& ulMode, TU3dv* const pXYFrom, TU3dv* const pXYTo, const double& t);
  //--------------------------------------------------------------------
  // Программа пересчета составляющих вектора скорости из подвижной СК,
  // связанной с носителем (СК А100), в СК УТ РМ и наоборот (A100->PM/PM->A100)
  // ulMode - параметр определяет направление пересчета
  void v2v(const unsigned long& ulMode,TU3d* const pXYFrom,TU3d* const pXYTo);
  //--------------------------------------------------------------------
  // Программа пересчета полярных координат (R,FI,H) из подвижной СК, 
  // связанной с носителем (СК А100), в прямоугольную СК УТ РМ (X,Y,H) и 
  // обратно (A100->PM/PM->A100)
  // ulMode - параметр определяет направление пересчета
  int polar(const unsigned long& ulMode,TUxyh* const pXYFrom,TUxyh* const pXYTo, const double& t);
  //-----------------------------------
  // Программа пересчитывает координаты точки (X,Y,H) из СК рабочей УТ (СК УТ)
  // в полярную СК (R,FI,H) связанную с носителем (СК А100)
  // return = 0 - true; return < 0 - false
  int xy2polar(TUxyh* const pXYFrom,TUxyh* const pXYTo, const double& t) { return polar(GEO_XYVTOA100, pXYFrom, pXYTo, t); }
  //-----------------------------------
  // Программа пересчитывает полярные координаты точки (R,FI,H) из СК, связанной 
  // с самолетом (СК А100), в координаты точки (X,Y,H) в СК рабочей УТ (СК УТ)
  // return = 0 - true; return < 0 - false
  int polar2xy(TUxyh* const pXYFrom,TUxyh* const pXYTo, const double& t) { return polar(GEO_XYVTOPM, pXYFrom, pXYTo, t); }
  //--------------------------------------------------------------------
  // Программа пересчета полярных координат (R,FI,Eps) в СК, 
  // связанную с носителем (СК А100), в геодезические координаты точки (B,L,H) 
  void polar2fl(TU3d *const pXYFrom, TUflh* const pFLHTo);
  //--------------------------------------------------------------------
  // Программа пересчета геодезических координат точки (B,L,H) в 
  // полярные координаты (R,FI,Eps) в СК, связанную с носителем (СК А100)
  void fl2polar(TUflh* const pFLHFrom, TU3d *const pXYTo, const double& t);
  //--------------------------------------------------------------------
  // Программа пересчета азимут точки относительно курса самолета в азимут 
  // точки относительно местного меридиана
  //template <class T> T fiPsi2nord(const T& fi)	
  template <class T> T beta2bett(const T& fi)	
  {
    T az = fi + psin;
    return (az > GEO_PI2) ? (az - GEO_PI2) : az;
  }
  //--------------------------------------------------------------------
  // Программа пересчета азимут точки относительно местного меридиана
  // в азимут точки относительно курса самолета
  //template <class T> T fiNord2psi(const T& fi)
  template <class T> T bett2beta(const T& fi)	
  {
    T az = fi - psin;
    return (az < 0.) ? (az + GEO_PI2) : az;
  }
  //--------------------------------------------------------------------
  // Программа пересчета параметров пеленга (азимут, угол места и прямоугольные 
  // координаты начала) из подвижной СК носителя в СК условной точки
  // pFLHTo – геодезические координаты (B,L,H) УТ ведущего А-100,если = NULL, то А-100 - ведущий
  // pXYZTo - прямоугольные координаты начала пеленга (координаты носителя)
  //          в СК УТ ведущего А-100
  // fiTo   – азимут пеленга в СК УТ ведущего А-100
  // epsTo  – угол места пеленга в СК УТ ведущего А-100
  void peleng(double* const fiTo,double* const epsTo,TU3d* const pXYZTo,
              const double& t,const double &fiFrom,const double &epsFrom=GEO_PI12,TUflh* const pFLHTo=NULL);

  //--------------------------------------------------------------------
  // Программа пересчета курса объекта из местной СК в СК УТ 
  // psi - курс в местной СК
  // l   - долгота местной СК
  double psiLocal2psiUT(const double &psi, const double &l)
  {
    return psi - (l - FLHk.l)*sin(FLHk.f);
  };
  //--------------------------------------------------------------------
  // заполнения зоны ZNav
  void fillZNav(TUflh * const FLH = NULL);
  //--------------------------------------------------------------------
  // вычисление коэффициентов пересчета из произвольной СК УТ (1) в другую СК УТ (2)
  void kof(TUflh* const pFLH1,TUflh* const pFLH2,double * const mkof);
  // вычисление коэффициентов пересчета из СК А100 в СК УТ РМ
  void kof(double * const mkof) { kof(NULL,NULL,mkof); }
};

/******************************************************************\
 Структура данных, которые позволяют пересчитывать координаты
 и скорости объектов из СК, связанной с рабочей условной точкой (УТ0),
 в СК, связанные с другими условными точками, и обратно.
 ulMode - параметр определяет направление пересчет и необходимость 
 восстановление координаты z по высоте h
 \******************************************************************/
struct TRecalcForm   // коэффициенты пересчета "УТ РМ <-> УТ ПАД(к)"
{
  double m[15];  // Коэффициенты для пересчета прямоугольных координат из СК УТ в СК ПАД
  double dfi,    // приращение географических координат
         dlam,   //   данной УТ ПАД относительно опорной УТ ПАД (УТ0 ПАД)
         ht,     // высота данной УТ ПАД
         ft;     // географическая широта данной УТ ПАД  (рад)
  double vert;   // радиуса кривизны первого вертикала эллипсоида Красовского в УТ ПАД

  TRecalcForm() { memset(this, 0, sizeof(*this)); }

  //
  void xyv2xyv (const unsigned long& ulMode,TU3dv* const pXYFrom,TU3dv* const pXYTo,TUflh* const pFLH = NULL);
  //--------------------------------------------------------------------
  // получить пpямоугольные кооpдинаты ПАД (x,y,z) в СК УТ РМ
  double getX(void)    { return  m[3];  } // получить x
  double getY(void)    { return  m[7];  } // получить y
  double getZ(void)    { return  m[11]; } // получить z
  //----------------------------------------------
  // получить пpямоугольные кооpд. УТ РМ в СК данной УТ ПАД
  double getXPad(void) { return  m[12]; } // получить x
  double getYPad(void) { return  m[13]; } // получить y
  double getZPad(void) { return  m[14]; } // получить z
};

/******************************************************************\
 Вычисление высоты объекта h по высоте пеленгатора (H), измеренной 
   наклонной дальности (D) и углу места (eps)
\******************************************************************/
inline double Deps2h(const double &h, const double &d, const double &eps)
{
  return ( h + d*sin(eps) + 0.5*d*d/GEO_RZ );
}

//////////////////////////
#pragma pack(pop)
//////////////////////////

/*-----------------------------------------------------------------*/
#endif          /* __ZNAV_H */
/*******************************************************************/
